diff --git a/backends/aarch64_retval.c b/backends/aarch64_retval.c
index 1308340b..f083c154 100644
--- a/backends/aarch64_retval.c
+++ b/backends/aarch64_retval.c
@@ -292,7 +292,7 @@ aarch64_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  assert (count > 0);
 	  if (count <= 4)
 	    return pass_hfa (locp, base_size, count);
-	  FALLTHROUGH;
+	  /* fall through */
 
 	case 1:
 	  /* Not a HFA.  */
diff --git a/backends/alpha_retval.c b/backends/alpha_retval.c
index d9bae3bc..05dddd35 100644
--- a/backends/alpha_retval.c
+++ b/backends/alpha_retval.c
@@ -85,7 +85,7 @@ alpha_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -131,7 +131,7 @@ alpha_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  }
       }
 
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
diff --git a/backends/arm_regs.c b/backends/arm_regs.c
index a46a4c99..cd0e7ec2 100644
--- a/backends/arm_regs.c
+++ b/backends/arm_regs.c
@@ -77,7 +77,7 @@ arm_register_info (Ebl *ebl __attribute__ ((unused)),
 
     case 16 + 0 ... 16 + 7:
       regno += 96 - 16;
-      FALLTHROUGH;
+      /* fall through */
     case 96 + 0 ... 96 + 7:
       *setname = "FPA";
       *type = DW_ATE_float;
diff --git a/backends/arm_retval.c b/backends/arm_retval.c
index 1c28f016..8f461826 100644
--- a/backends/arm_retval.c
+++ b/backends/arm_retval.c
@@ -82,7 +82,7 @@ arm_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
diff --git a/backends/i386_regs.c b/backends/i386_regs.c
index 7ec93bb9..bf1fae92 100644
--- a/backends/i386_regs.c
+++ b/backends/i386_regs.c
@@ -92,7 +92,7 @@ i386_register_info (Ebl *ebl __attribute__ ((unused)),
     case 5:
     case 8:
       *type = DW_ATE_address;
-      FALLTHROUGH;
+      /* fall through */
     case 0 ... 3:
     case 6 ... 7:
       name[0] = 'e';
diff --git a/backends/i386_retval.c b/backends/i386_retval.c
index 32fec728..9169aa69 100644
--- a/backends/i386_retval.c
+++ b/backends/i386_retval.c
@@ -85,7 +85,7 @@ i386_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -123,7 +123,7 @@ i386_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	if (size <= 8)
 	  return nloc_intregpair;
       }
-    FALLTHROUGH;
+    /* fall through */
 
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
diff --git a/backends/ia64_retval.c b/backends/ia64_retval.c
index 03ea4d89..41e1b95c 100644
--- a/backends/ia64_retval.c
+++ b/backends/ia64_retval.c
@@ -260,7 +260,7 @@ ia64_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
diff --git a/backends/linux-core-note.c b/backends/linux-core-note.c
index 9faae4c3..bb2de976 100644
--- a/backends/linux-core-note.c
+++ b/backends/linux-core-note.c
@@ -226,7 +226,7 @@ EBLHOOK(core_note) (const GElf_Nhdr *nhdr, const char *name,
       if (memcmp (name, "CORE", nhdr->n_namesz) == 0)
 	break;
       /* Buggy old Linux kernels didn't terminate "LINUX".  */
-      FALLTHROUGH;
+      /* fall through */
 
     case sizeof "LINUX":
       if (memcmp (name, "LINUX", nhdr->n_namesz) == 0)
diff --git a/backends/m68k_retval.c b/backends/m68k_retval.c
index a653ba3a..0f85bcf6 100644
--- a/backends/m68k_retval.c
+++ b/backends/m68k_retval.c
@@ -92,7 +92,7 @@ m68k_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -135,7 +135,7 @@ m68k_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	if (size <= 8)
 	  return nloc_intregpair;
       }
-      FALLTHROUGH;
+      /* fall through */
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
     case DW_TAG_union_type:
diff --git a/backends/ppc64_retval.c b/backends/ppc64_retval.c
index eb1c11ec..d4d406f2 100644
--- a/backends/ppc64_retval.c
+++ b/backends/ppc64_retval.c
@@ -96,7 +96,7 @@ ppc64_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -141,7 +141,7 @@ ppc64_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  return nloc_intreg;
 	}
 
-      FALLTHROUGH;
+      /* fall through */
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
     case DW_TAG_union_type:
@@ -161,7 +161,7 @@ ppc64_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	    return nloc_vmxreg;
 	  }
       }
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_string_type:
       if (dwarf_aggregate_size (typedie, &size) == 0 && size <= 8)
diff --git a/backends/ppc_regs.c b/backends/ppc_regs.c
index 43d2534f..09db9e68 100644
--- a/backends/ppc_regs.c
+++ b/backends/ppc_regs.c
@@ -140,7 +140,7 @@ ppc_register_info (Ebl *ebl __attribute__ ((unused)),
     case 100:
       if (*bits == 32)
 	return stpcpy (name, "mq") + 1 - name;
-      FALLTHROUGH;
+      /* fall through */
     case 102 ... 107:
       name[0] = 's';
       name[1] = 'p';
diff --git a/backends/ppc_retval.c b/backends/ppc_retval.c
index 39b42da1..38aa3316 100644
--- a/backends/ppc_retval.c
+++ b/backends/ppc_retval.c
@@ -108,7 +108,7 @@ ppc_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -172,7 +172,7 @@ ppc_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	      return nloc_intregquad;
 	    }
       }
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
diff --git a/backends/s390_retval.c b/backends/s390_retval.c
index 2043f985..4641ef14 100644
--- a/backends/s390_retval.c
+++ b/backends/s390_retval.c
@@ -87,7 +87,7 @@ s390_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -127,7 +127,7 @@ s390_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	    return size <= asize ? nloc_intreg : nloc_intregpair;
 	  }
       }
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
diff --git a/backends/sh_retval.c b/backends/sh_retval.c
index 33d7d964..321bbfc1 100644
--- a/backends/sh_retval.c
+++ b/backends/sh_retval.c
@@ -84,7 +84,7 @@ sh_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
diff --git a/backends/sparc_retval.c b/backends/sparc_retval.c
index fb81cdce..24077ef1 100644
--- a/backends/sparc_retval.c
+++ b/backends/sparc_retval.c
@@ -91,7 +91,7 @@ sparc_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
diff --git a/backends/tilegx_retval.c b/backends/tilegx_retval.c
index 7f7d24b0..3798e24f 100644
--- a/backends/tilegx_retval.c
+++ b/backends/tilegx_retval.c
@@ -79,7 +79,7 @@ tilegx_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
@@ -113,7 +113,7 @@ tilegx_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  return nloc_intreg;
 	}
 
-      FALLTHROUGH;
+      /* fall through */
     case DW_TAG_structure_type:
     case DW_TAG_class_type:
     case DW_TAG_union_type:
diff --git a/backends/x86_64_regs.c b/backends/x86_64_regs.c
index ef987daf..c1dfe6fd 100644
--- a/backends/x86_64_regs.c
+++ b/backends/x86_64_regs.c
@@ -87,7 +87,7 @@ x86_64_register_info (Ebl *ebl __attribute__ ((unused)),
 
     case 6 ... 7:
       *type = DW_ATE_address;
-      FALLTHROUGH;
+      /* fall through */
     case 0 ... 5:
       name[0] = 'r';
       name[1] = baseregs[regno][0];
diff --git a/backends/x86_64_retval.c b/backends/x86_64_retval.c
index f9114cb1..c1f87b6a 100644
--- a/backends/x86_64_retval.c
+++ b/backends/x86_64_retval.c
@@ -100,7 +100,7 @@ x86_64_return_value_location (Dwarf_Die *functypedie, const Dwarf_Op **locp)
 	  typedie = dwarf_formref_die (attr, &die_mem);
 	  tag = DWARF_TAG_OR_RETURN (typedie);
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case DW_TAG_base_type:
     case DW_TAG_enumeration_type:
diff --git a/configure.ac b/configure.ac
index b4e012de..f00877a3 100644
--- a/configure.ac
+++ b/configure.ac
@@ -125,7 +125,7 @@ void baz (int n)
 		  ac_cv_c99=yes, ac_cv_c99=no)
 CFLAGS="$old_CFLAGS"])
 AS_IF([test "x$ac_cv_c99" != xyes],
-      AC_MSG_ERROR([gcc with GNU99 support required]))
+      AC_MSG_WARN([gcc with GNU99 support required]))
 
 AC_CACHE_CHECK([whether gcc supports __attribute__((visibility()))],
 	ac_cv_visibility, [dnl
@@ -485,7 +485,7 @@ if test "$libc_has_argp" = "false" ; then
 	AC_CHECK_LIB([argp], [argp_parse], [have_argp="true"], [have_argp="false"])
 
 	if test "$have_argp" = "false"; then
-		AC_MSG_ERROR("no libargp found")
+		AC_MSG_WARN("no libargp found")
 	else
 		argp_LDADD="-largp"
 	fi
diff --git a/lib/eu-config.h b/lib/eu-config.h
index 84b22d7c..befdfcfa 100644
--- a/lib/eu-config.h
+++ b/lib/eu-config.h
@@ -198,12 +198,4 @@ asm (".section predict_data, \"aw\"; .previous\n"
 # define COMPAT_VERSION(name, version, prefix) error "should use #ifdef SYMBOL_VERSIONING"
 #endif
 
-#ifndef FALLTHROUGH
-# ifdef HAVE_FALLTHROUGH
-#  define FALLTHROUGH __attribute__ ((fallthrough))
-# else
-#  define FALLTHROUGH ((void) 0)
-# endif
-#endif
-
 #endif	/* eu-config.h */
diff --git a/lib/system.h b/lib/system.h
index 292082bd..172456d2 100644
--- a/lib/system.h
+++ b/lib/system.h
@@ -33,6 +33,7 @@
 #include <error.h>
 #include <stddef.h>
 #include <stdint.h>
+#include <string.h>
 #include <sys/param.h>
 #include <endian.h>
 #include <byteswap.h>
diff --git a/libasm/asm_newscn.c b/libasm/asm_newscn.c
index 7cdf484f..062834ee 100644
--- a/libasm/asm_newscn.c
+++ b/libasm/asm_newscn.c
@@ -46,8 +46,8 @@
    dirty tricks here.  */
 static const struct
 {
-  struct FillPattern pattern;
   char zero;
+  struct FillPattern pattern;
 } xdefault_pattern =
   {
     .pattern =
diff --git a/libcpu/i386_disasm.c b/libcpu/i386_disasm.c
index a7e03f95..96d638eb 100644
--- a/libcpu/i386_disasm.c
+++ b/libcpu/i386_disasm.c
@@ -819,7 +819,7 @@ i386_disasm (Ebl *ebl __attribute__((unused)),
 			      ++param_start;
 			      break;
 			    }
-			  FALLTHROUGH;
+			  /* fall through */
 			default:
 			  assert (! "INVALID not handled");
 			}
diff --git a/libdw/cfi.c b/libdw/cfi.c
index 341e055b..a6060638 100644
--- a/libdw/cfi.c
+++ b/libdw/cfi.c
@@ -138,7 +138,7 @@ execute_cfi (Dwarf_CFI *cache,
 
 	case DW_CFA_advance_loc1:
 	  operand = *program++;
-	  FALLTHROUGH;
+	  /* fall through */
 	case DW_CFA_advance_loc + 0 ... DW_CFA_advance_loc + CFI_PRIMARY_MAX:
 	advance_loc:
 	  loc += operand * cie->code_alignment_factor;
@@ -301,7 +301,7 @@ execute_cfi (Dwarf_CFI *cache,
 
 	case DW_CFA_restore_extended:
 	  get_uleb128 (operand, program, end);
-	  FALLTHROUGH;
+	  /* fall through */
 	case DW_CFA_restore + 0 ... DW_CFA_restore + CFI_PRIMARY_MAX:
 
 	  if (unlikely (abi_cfi) && likely (opcode == DW_CFA_restore))
diff --git a/libdw/dwarf_frame_register.c b/libdw/dwarf_frame_register.c
index d0159fb8..bd5972cd 100644
--- a/libdw/dwarf_frame_register.c
+++ b/libdw/dwarf_frame_register.c
@@ -62,7 +62,7 @@ dwarf_frame_register (Dwarf_Frame *fs, int regno, Dwarf_Op *ops_mem,
       /* Use the default rule for registers not yet mentioned in CFI.  */
       if (fs->cache->default_same_value)
 	goto same_value;
-      FALLTHROUGH;
+      /* fall through */
     case reg_undefined:
       /* The value is known to be unavailable.  */
       break;
diff --git a/libdwfl/dwfl_report_elf.c b/libdwfl/dwfl_report_elf.c
index 3fc9384a..cdaa2111 100644
--- a/libdwfl/dwfl_report_elf.c
+++ b/libdwfl/dwfl_report_elf.c
@@ -174,7 +174,7 @@ __libdwfl_elf_address_range (Elf *elf, GElf_Addr base, bool add_p_vaddr,
       /* An assigned base address is meaningless for these.  */
       base = 0;
       add_p_vaddr = true;
-      FALLTHROUGH;
+      /* fall through */
     case ET_DYN:
     default:;
       size_t phnum;
diff --git a/libdwfl/dwfl_segment_report_module.c b/libdwfl/dwfl_segment_report_module.c
index 76ba1506..b7160ae3 100644
--- a/libdwfl/dwfl_segment_report_module.c
+++ b/libdwfl/dwfl_segment_report_module.c
@@ -31,6 +31,7 @@
 #undef	_
 #include "libdwflP.h"
 #include "common.h"
+#include "nested_func.h"
 
 #include <elf.h>
 #include <gelf.h>
@@ -54,6 +55,9 @@
 # define MY_ELFDATA	ELFDATA2MSB
 #endif
 
+#ifndef UNUSED
+#define UNUSED(x) (void)(x)
+#endif
 
 /* Return user segment index closest to ADDR but not above it.
    If NEXT, return the closest to ADDR but not below it.  */
@@ -233,15 +237,20 @@ invalid_elf (Elf *elf, bool disk_file_has_build_id,
 }
 
 int
-dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
-			    Dwfl_Memory_Callback *memory_callback,
-			    void *memory_callback_arg,
-			    Dwfl_Module_Callback *read_eagerly,
-			    void *read_eagerly_arg,
-			    const void *note_file, size_t note_file_size,
-			    const struct r_debug_info *r_debug_info)
+dwfl_segment_report_module (Dwfl *dwfl, int const ndx_in, const char* const name_in,
+			    Dwfl_Memory_Callback* const memory_callback,
+			    void* const memory_callback_arg,
+			    Dwfl_Module_Callback * const read_eagerly,
+			    void* const read_eagerly_arg,
+			    const void* const note_file, size_t const note_file_size,
+			    const struct r_debug_info* const r_debug_info)
 {
-  size_t segment = ndx;
+  UNUSED(memory_callback);
+  UNUSED(memory_callback_arg);
+  __BLOCK int ndx = ndx_in;
+  __BLOCK const char *name = name_in;
+
+  __BLOCK size_t segment = ndx;
 
   if (segment >= dwfl->lookup_elts)
     segment = dwfl->lookup_elts - 1;
@@ -255,34 +264,38 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
     if (++segment == dwfl->lookup_elts)
       return 0;
 
-  GElf_Addr start = dwfl->lookup_addr[segment];
+  __BLOCK GElf_Addr start = dwfl->lookup_addr[segment];
 
-  inline bool segment_read (int segndx,
-			    void **buffer, size_t *buffer_available,
-			    GElf_Addr addr, size_t minread)
+  INLINE_NESTED_FUNC (bool, segment_read,
+                      (int , void **, size_t *, GElf_Addr, size_t),
+                      (int segndx,
+                       void **buffer, size_t *buffer_available,
+                       GElf_Addr addr, size_t minread))
   {
     return ! (*memory_callback) (dwfl, segndx, buffer, buffer_available,
 				 addr, minread, memory_callback_arg);
-  }
+  };
 
-  inline void release_buffer (void **buffer, size_t *buffer_available)
+  INLINE_NESTED_FUNC (void, release_buffer,
+                      (void **, size_t *),
+                      (void **buffer, size_t *buffer_available))
   {
     if (*buffer != NULL)
       (void) segment_read (-1, buffer, buffer_available, 0, 0);
-  }
+  };
 
   /* First read in the file header and check its sanity.  */
 
-  void *buffer = NULL;
-  size_t buffer_available = INITIAL_READ;
-  Elf *elf = NULL;
-  int fd = -1;
+  __BLOCK void *buffer = NULL;
+  __BLOCK size_t buffer_available = INITIAL_READ;
+  __BLOCK Elf *elf = NULL;
+  __BLOCK int fd = -1;
 
   /* We might have to reserve some memory for the phdrs.  Set to NULL
      here so we can always safely free it.  */
-  void *phdrsp = NULL;
+  __BLOCK void *phdrsp = NULL;
 
-  inline int finish (void)
+  INLINE_NESTED_FUNC (int, finish, (void), (void))
   {
     free (phdrsp);
     release_buffer (&buffer, &buffer_available);
@@ -291,15 +304,17 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
     if (fd != -1)
       close (fd);
     return ndx;
-  }
+  };
 
   if (segment_read (ndx, &buffer, &buffer_available,
 		    start, sizeof (Elf64_Ehdr))
       || memcmp (buffer, ELFMAG, SELFMAG) != 0)
     return finish ();
 
-  inline bool read_portion (void **data, size_t *data_size,
-			    GElf_Addr vaddr, size_t filesz)
+  INLINE_NESTED_FUNC (bool, read_portion,
+                      (void **, size_t *, GElf_Addr, size_t),
+                      (void **data, size_t *data_size,
+                       GElf_Addr vaddr, size_t filesz))
   {
     /* Check whether we will have to read the segment data, or if it
        can be returned from the existing buffer.  */
@@ -320,35 +335,37 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
     *data = vaddr - start + buffer;
     *data_size = 0;
     return false;
-  }
+  };
 
-  inline void finish_portion (void **data, size_t *data_size)
+  INLINE_NESTED_FUNC (void, finish_portion,
+                      (void **, size_t *),
+                      (void **data, size_t *data_size))
   {
     if (*data_size != 0)
       release_buffer (data, data_size);
-  }
+  };
 
   /* Extract the information we need from the file header.  */
-  const unsigned char *e_ident;
-  unsigned char ei_class;
-  unsigned char ei_data;
-  uint16_t e_type;
-  union
+  __BLOCK const unsigned char *e_ident;
+  __BLOCK unsigned char ei_class;
+  __BLOCK unsigned char ei_data;
+  __BLOCK uint16_t e_type;
+  __BLOCK union
   {
     Elf32_Ehdr e32;
     Elf64_Ehdr e64;
   } ehdr;
-  GElf_Off phoff;
-  uint_fast16_t phnum;
-  uint_fast16_t phentsize;
-  GElf_Off shdrs_end;
-  Elf_Data xlatefrom =
+  __BLOCK GElf_Off phoff;
+  __BLOCK uint_fast16_t phnum;
+  __BLOCK uint_fast16_t phentsize;
+  __BLOCK GElf_Off shdrs_end;
+  __BLOCK Elf_Data xlatefrom =
     {
       .d_type = ELF_T_EHDR,
       .d_buf = (void *) buffer,
       .d_version = EV_CURRENT,
     };
-  Elf_Data xlateto =
+  __BLOCK Elf_Data xlateto =
     {
       .d_type = ELF_T_EHDR,
       .d_buf = &ehdr,
@@ -406,8 +423,8 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
   xlatefrom.d_type = xlateto.d_type = ELF_T_PHDR;
   xlatefrom.d_size = phnum * phentsize;
 
-  void *ph_buffer = NULL;
-  size_t ph_buffer_size = 0;
+  __BLOCK void *ph_buffer = NULL;
+  __BLOCK size_t ph_buffer_size = 0;
   if (read_portion (&ph_buffer, &ph_buffer_size,
 		    start + phoff, xlatefrom.d_size))
     return finish ();
@@ -433,32 +450,33 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
   xlateto.d_size = phdrsp_bytes;
 
   /* Track the bounds of the file visible in memory.  */
-  GElf_Off file_trimmed_end = 0; /* Proper p_vaddr + p_filesz end.  */
-  GElf_Off file_end = 0;	 /* Rounded up to effective page size.  */
-  GElf_Off contiguous = 0;	 /* Visible as contiguous file from START.  */
-  GElf_Off total_filesz = 0;	 /* Total size of data to read.  */
+  __BLOCK GElf_Off file_trimmed_end = 0; /* Proper p_vaddr + p_filesz end.  */
+  __BLOCK GElf_Off file_end = 0;	 /* Rounded up to effective page size.  */
+  __BLOCK GElf_Off contiguous = 0;	 /* Visible as contiguous file from START.  */
+  __BLOCK GElf_Off total_filesz = 0;	 /* Total size of data to read.  */
 
   /* Collect the bias between START and the containing PT_LOAD's p_vaddr.  */
-  GElf_Addr bias = 0;
-  bool found_bias = false;
+  __BLOCK GElf_Addr bias = 0;
+  __BLOCK bool found_bias = false;
 
   /* Collect the unbiased bounds of the module here.  */
-  GElf_Addr module_start = -1l;
-  GElf_Addr module_end = 0;
-  GElf_Addr module_address_sync = 0;
+  __BLOCK GElf_Addr module_start = -1l;
+  __BLOCK GElf_Addr module_end = 0;
+  __BLOCK GElf_Addr module_address_sync = 0;
 
   /* If we see PT_DYNAMIC, record it here.  */
-  GElf_Addr dyn_vaddr = 0;
-  GElf_Xword dyn_filesz = 0;
+  __BLOCK GElf_Addr dyn_vaddr = 0;
+  __BLOCK GElf_Xword dyn_filesz = 0;
 
   /* Collect the build ID bits here.  */
-  void *build_id = NULL;
-  size_t build_id_len = 0;
-  GElf_Addr build_id_vaddr = 0;
+  __BLOCK void *build_id = NULL;
+  __BLOCK size_t build_id_len = 0;
+  __BLOCK GElf_Addr build_id_vaddr = 0;
 
   /* Consider a PT_NOTE we've found in the image.  */
-  inline void consider_notes (GElf_Addr vaddr, GElf_Xword filesz,
-			      GElf_Xword align)
+  INLINE_NESTED_FUNC (void, consider_notes,
+                      (GElf_Addr, GElf_Xword, GElf_Xword),
+                      (GElf_Addr vaddr, GElf_Xword filesz, GElf_Xword align))
   {
     /* If we have already seen a build ID, we don't care any more.  */
     if (build_id != NULL || filesz == 0)
@@ -535,13 +553,18 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
     if (notes != data)
       free (notes);
     finish_portion (&data, &data_size);
-  }
+  };
 
   /* Consider each of the program headers we've read from the image.  */
-  inline void consider_phdr (GElf_Word type,
-			     GElf_Addr vaddr, GElf_Xword memsz,
-			     GElf_Off offset, GElf_Xword filesz,
-			     GElf_Xword align)
+  INLINE_NESTED_FUNC (void, consider_phdr,
+                      (GElf_Word,
+                       GElf_Addr, GElf_Xword,
+                       GElf_Off, GElf_Xword,
+                       GElf_Xword),
+                      (GElf_Word type,
+                       GElf_Addr vaddr, GElf_Xword memsz,
+                       GElf_Off offset, GElf_Xword filesz,
+                       GElf_Xword align))
   {
     switch (type)
       {
@@ -604,7 +627,7 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
 	  module_end = vaddr_end;
 	break;
       }
-  }
+  };
 
   Elf32_Phdr (*p32)[phnum] = phdrsp;
   Elf64_Phdr (*p64)[phnum] = phdrsp;
@@ -751,11 +774,12 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
      We need its DT_STRTAB and DT_STRSZ to decipher DT_SONAME,
      and they also tell us the essential portion of the file
      for fetching symbols.  */
-  GElf_Addr soname_stroff = 0;
-  GElf_Addr dynstr_vaddr = 0;
-  GElf_Xword dynstrsz = 0;
-  bool execlike = false;
-  inline bool consider_dyn (GElf_Sxword tag, GElf_Xword val)
+  __BLOCK GElf_Addr soname_stroff = 0;
+  __BLOCK GElf_Addr dynstr_vaddr = 0;
+  __BLOCK GElf_Xword dynstrsz = 0;
+  __BLOCK bool execlike = false;
+  INLINE_NESTED_FUNC (bool, consider_dyn, (GElf_Sxword, GElf_Xword),
+                      (GElf_Sxword tag, GElf_Xword val))
   {
     switch (tag)
       {
@@ -780,12 +804,12 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
       }
 
     return soname_stroff != 0 && dynstr_vaddr != 0 && dynstrsz != 0;
-  }
+  };
 
   const size_t dyn_entsize = (ei_class == ELFCLASS32
 			      ? sizeof (Elf32_Dyn) : sizeof (Elf64_Dyn));
-  void *dyn_data = NULL;
-  size_t dyn_data_size = 0;
+  __BLOCK void *dyn_data = NULL;
+  __BLOCK size_t dyn_data_size = 0;
   if (dyn_filesz != 0 && dyn_filesz % dyn_entsize == 0
       && ! read_portion (&dyn_data, &dyn_data_size, dyn_vaddr, dyn_filesz))
     {
@@ -829,8 +853,8 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
   if (name == NULL)
     name = e_type == ET_EXEC ? "[exe]" : execlike ? "[pie]" : "[dso]";
 
-  void *soname = NULL;
-  size_t soname_size = 0;
+  __BLOCK void *soname = NULL;
+ __BLOCK size_t soname_size = 0;
   if (! name_is_final && dynstrsz != 0 && dynstr_vaddr != 0)
     {
       /* We know the bounds of the .dynstr section.
@@ -863,7 +887,7 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
   /* Now that we have chosen the module's name and bounds, report it.
      If we found a build ID, report that too.  */
 
-  Dwfl_Module *mod = INTUSE(dwfl_report_module) (dwfl, name,
+  __BLOCK Dwfl_Module *mod = INTUSE(dwfl_report_module) (dwfl, name,
 						 module_start, module_end);
 
   // !execlike && ET_EXEC is PIE.
@@ -911,29 +935,34 @@ dwfl_segment_report_module (Dwfl *dwfl, int ndx, const char *name,
       /* The caller wants to read the whole file in right now, but hasn't
 	 done it for us.  Fill in a local image of the virtual file.  */
 
-      void *contents = calloc (1, file_trimmed_end);
+      __BLOCK void *contents = calloc (1, file_trimmed_end);
       if (unlikely (contents == NULL))
 	return finish ();
 
-      inline void final_read (size_t offset, GElf_Addr vaddr, size_t size)
+      INLINE_NESTED_FUNC (void, final_read,
+                          (size_t, GElf_Addr, size_t),
+                          (size_t offset, GElf_Addr vaddr, size_t size))
       {
 	void *into = contents + offset;
 	size_t read_size = size;
 	(void) segment_read (addr_segndx (dwfl, segment, vaddr, false),
 			     &into, &read_size, vaddr, size);
-      }
+      };
 
       if (contiguous < file_trimmed_end)
 	{
 	  /* We can't use the memory image verbatim as the file image.
 	     So we'll be reading into a local image of the virtual file.  */
 
-	  inline void read_phdr (GElf_Word type, GElf_Addr vaddr,
-				 GElf_Off offset, GElf_Xword filesz)
-	  {
+	  INLINE_NESTED_FUNC (void, read_phdr,
+	                      (GElf_Word, GElf_Addr,
+	                       GElf_Off, GElf_Xword),
+	                      (GElf_Word type, GElf_Addr vaddr,
+	                       GElf_Off offset, GElf_Xword filesz))
+ 	  {
 	    if (type == PT_LOAD)
 	      final_read (offset, vaddr + bias, filesz);
-	  }
+	  };
 
 	  if (ei_class == ELFCLASS32)
 	    for (uint_fast16_t i = 0; i < phnum; ++i)
diff --git a/libdwfl/elf-from-memory.c b/libdwfl/elf-from-memory.c
index c54c1b99..73d78aa7 100644
--- a/libdwfl/elf-from-memory.c
+++ b/libdwfl/elf-from-memory.c
@@ -225,33 +225,37 @@ elf_from_remote_memory (GElf_Addr ehdr_vma,
   Elf64_Phdr (*p64)[phnum] = phdrsp;
   switch (ehdr.e32.e_ident[EI_CLASS])
     {
-      /* Sanity checks segments and calculates segment_end,
-	 segments_end, segments_end_mem and loadbase (if not
-	 found_base yet).  Returns true if sanity checking failed,
-	 false otherwise.  */
-      inline bool handle_segment (GElf_Addr vaddr, GElf_Off offset,
-				  GElf_Xword filesz, GElf_Xword memsz)
-	{
-	  /* Sanity check the segment load aligns with the pagesize.  */
-	  if (((vaddr - offset) & (pagesize - 1)) != 0)
-	    return true;
-
-	  GElf_Off segment_end = ((offset + filesz + pagesize - 1)
-				  & -pagesize);
-
-	  if (segment_end > (GElf_Off) contents_size)
-	    contents_size = segment_end;
-
-	  if (!found_base && (offset & -pagesize) == 0)
-	    {
-	      loadbase = ehdr_vma - (vaddr & -pagesize);
-	      found_base = true;
-	    }
-
-	  segments_end = offset + filesz;
-	  segments_end_mem = offset + memsz;
-	  return false;
-	}
+/* Sanity checks segments and calculates segment_end,
+   segments_end, segments_end_mem and loadbase (if not
+   found_base yet).  Returns true if sanity checking failed,
+   false otherwise.  */
+#define handle_segment(_vaddr, _offset, _filesz, _memsz) \
+( { \
+    bool result; \
+    GElf_Addr vaddr = _vaddr; \
+    GElf_Off offset = _offset; \
+    GElf_Xword filesz = _filesz; \
+    GElf_Xword memsz = _memsz; \
+    /* Sanity check the segment load aligns with the pagesize.  */ \
+    if (((vaddr - offset) & (pagesize - 1)) != 0) \
+        result = true; \
+    else \
+    { \
+        result = false; \
+        GElf_Off segment_end = ((offset + filesz + pagesize - 1) \
+                                & -pagesize); \
+        if (segment_end > (GElf_Off) contents_size) \
+        contents_size = segment_end; \
+        if (!found_base && (offset & -pagesize) == 0) \
+        { \
+            loadbase = ehdr_vma - (vaddr & -pagesize); \
+            found_base = true; \
+        } \
+        segments_end = offset + filesz; \
+        segments_end_mem = offset + memsz; \
+    } \
+    result; \
+} )
 
     case ELFCLASS32:
       if (elf32_xlatetom (&xlateto, &xlatefrom,
@@ -309,18 +313,21 @@ elf_from_remote_memory (GElf_Addr ehdr_vma,
     {
       /* Reads the given segment.  Returns true if reading fails,
 	 false otherwise.  */
-      inline bool handle_segment (GElf_Addr vaddr, GElf_Off offset,
-				  GElf_Xword filesz)
-	{
-	  GElf_Off start = offset & -pagesize;
-	  GElf_Off end = (offset + filesz + pagesize - 1) & -pagesize;
-	  if (end > (GElf_Off) contents_size)
-	    end = contents_size;
-	  nread = (*read_memory) (arg, buffer + start,
-				  (loadbase + vaddr) & -pagesize,
-				  end - start, end - start);
-	  return nread <= 0;
-	}
+#undef handle_segment
+#define handle_segment(_vaddr, _offset, _filesz) \
+( { \
+    GElf_Addr vaddr = _vaddr; \
+    GElf_Off offset = _offset; \
+    GElf_Xword filesz = _filesz; \
+    GElf_Off start = offset & -pagesize; \
+    GElf_Off end = (offset + filesz + pagesize - 1) & -pagesize; \
+    if (end > (GElf_Off) contents_size) \
+    end = contents_size; \
+    nread = (*read_memory) (arg, buffer + start, \
+                            (loadbase + vaddr) & -pagesize, \
+                            end - start, end - start); \
+    (nread <= 0); \
+} )
 
     case ELFCLASS32:
       for (uint_fast16_t i = 0; i < phnum; ++i)
diff --git a/libdwfl/frame_unwind.c b/libdwfl/frame_unwind.c
index d7dfa5a9..f8f4bf94 100644
--- a/libdwfl/frame_unwind.c
+++ b/libdwfl/frame_unwind.c
@@ -442,7 +442,7 @@ expr_eval (Dwfl_Frame *state, Dwarf_Frame *frame, const Dwarf_Op *ops,
 	    }
 	  if (val1 == 0)
 	    break;
-	  FALLTHROUGH;
+	  /* fall through */
 	case DW_OP_skip:;
 	  Dwarf_Word offset = op->offset + 1 + 2 + (int16_t) op->number;
 	  const Dwarf_Op *found = bsearch ((void *) (uintptr_t) offset, ops, nops,
diff --git a/libdwfl/link_map.c b/libdwfl/link_map.c
index 29307c74..c8056967 100644
--- a/libdwfl/link_map.c
+++ b/libdwfl/link_map.c
@@ -30,6 +30,7 @@
 #include "libdwflP.h"
 #include "../libdw/memory-access.h"
 #include "system.h"
+#include <nested_func.h>
 
 #include <byteswap.h>
 #include <endian.h>
@@ -245,20 +246,27 @@ report_r_debug (uint_fast8_t elfclass, uint_fast8_t elfdata,
 		struct r_debug_info *r_debug_info)
 {
   /* Skip r_version, to aligned r_map field.  */
-  GElf_Addr read_vaddr = r_debug_vaddr + addrsize (elfclass);
+  __BLOCK GElf_Addr read_vaddr = r_debug_vaddr + addrsize (elfclass);
 
-  void *buffer = NULL;
-  size_t buffer_available = 0;
-  inline int release_buffer (int result)
+  __BLOCK void *buffer = NULL;
+  __BLOCK size_t buffer_available = 0;
+  INLINE_NESTED_FUNC (int, release_buffer, (int), (int result))
   {
     if (buffer != NULL)
       (void) (*memory_callback) (dwfl, -1, &buffer, &buffer_available, 0, 0,
 				 memory_callback_arg);
     return result;
-  }
-
-  GElf_Addr addrs[4];
-  inline bool read_addrs (GElf_Addr vaddr, size_t n)
+  };
+
+#if __clang__
+  /* Clang Blocks cannot copy an array to a closure. */
+  __BLOCK GElf_Addr *addrs = alloca(4 * sizeof (GElf_Addr));
+#else
+  /* gcc complains about unbounded stack usage from alloca. */
+   GElf_Addr addrs[4];
+#endif
+  INLINE_NESTED_FUNC (bool, read_addrs,
+                      (GElf_Addr, size_t), (GElf_Addr vaddr, size_t n))
   {
     size_t nb = n * addrsize (elfclass); /* Address words -> bytes to read.  */
 
@@ -301,7 +309,7 @@ report_r_debug (uint_fast8_t elfclass, uint_fast8_t elfdata,
       }
 
     return false;
-  }
+  };
 
   if (unlikely (read_addrs (read_vaddr, 1)))
     return release_buffer (-1);
@@ -694,17 +702,17 @@ dwfl_link_map_report (Dwfl *dwfl, const void *auxv, size_t auxv_size,
 		      void *memory_callback_arg,
 		      struct r_debug_info *r_debug_info)
 {
-  GElf_Addr r_debug_vaddr = 0;
+  __BLOCK GElf_Addr r_debug_vaddr = 0;
 
-  uint_fast8_t elfclass = ELFCLASSNONE;
-  uint_fast8_t elfdata = ELFDATANONE;
+  __BLOCK uint_fast8_t elfclass = ELFCLASSNONE;
+  __BLOCK uint_fast8_t elfdata = ELFDATANONE;
   if (likely (auxv != NULL)
       && likely (auxv_format_probe (auxv, auxv_size, &elfclass, &elfdata)))
     {
-      GElf_Addr entry = 0;
-      GElf_Addr phdr = 0;
-      GElf_Xword phent = 0;
-      GElf_Xword phnum = 0;
+      __BLOCK GElf_Addr entry = 0;
+      __BLOCK GElf_Addr phdr = 0;
+      __BLOCK GElf_Xword phent = 0;
+      __BLOCK GElf_Xword phnum = 0;
 
 #define READ_AUXV32(ptr)	read_4ubyte_unaligned_noncvt (ptr)
 #define READ_AUXV64(ptr)	read_8ubyte_unaligned_noncvt (ptr)
@@ -754,12 +762,13 @@ dwfl_link_map_report (Dwfl *dwfl, const void *auxv, size_t auxv_size,
 	}
 
       /* If we found the phdr dimensions, search phdrs for PT_DYNAMIC.  */
-      GElf_Addr dyn_vaddr = 0;
-      GElf_Xword dyn_filesz = 0;
-      GElf_Addr dyn_bias = (GElf_Addr) -1;
+      __BLOCK GElf_Addr dyn_vaddr = 0;
+      __BLOCK GElf_Xword dyn_filesz = 0;
+      __BLOCK GElf_Addr dyn_bias = (GElf_Addr) -1;
 
-      inline bool consider_phdr (GElf_Word type,
-				 GElf_Addr vaddr, GElf_Xword filesz)
+      INLINE_NESTED_FUNC (bool, consider_phdr,
+                          (GElf_Word, GElf_Addr, GElf_Xword),
+                          (GElf_Word type, GElf_Addr vaddr, GElf_Xword filesz))
       {
 	switch (type)
 	  {
@@ -781,7 +790,7 @@ dwfl_link_map_report (Dwfl *dwfl, const void *auxv, size_t auxv_size,
 	  }
 
 	return false;
-      }
+      };
 
       if (phdr != 0 && phnum != 0)
 	{
diff --git a/libdwfl/nested_func.h b/libdwfl/nested_func.h
index e69de29b..46e4f506 100644
--- a/libdwfl/nested_func.h
+++ b/libdwfl/nested_func.h
@@ -0,0 +1,86 @@
+/* Copyright (C) 2015 Red Hat, Inc.
+   This file is part of elfutils.
+   Written by Chih-Hung Hsieh <chh(a)google.com>, 2015.
+
+   This file is free software; you can redistribute it and/or modify
+   it under the terms of either
+
+     * the GNU Lesser General Public License as published by the Free
+       Software Foundation; either version 3 of the License, or (at
+       your option) any later version
+
+   or
+
+     * the GNU General Public License as published by the Free
+       Software Foundation; either version 2 of the License, or (at
+       your option) any later version
+
+   or both in parallel, as here.
+
+   elfutils is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received copies of the GNU General Public License and
+   the GNU Lesser General Public License along with this program.  If
+   not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _NESTED_FUNC_H
+#define _NESTED_FUNC_H 1
+
+#if __clang__
+
+  #define __BLOCK __block
+
+  #define NESTED_FUNC(return_type, function_name, \
+                      arg_types, arg_types_and_names) \
+    return_type (^function_name) arg_types = \
+        ^ return_type arg_types_and_names
+
+  /* Clang does not like inline keyword before a block variable. */
+  #define INLINE_NESTED_FUNC(r, f, t, a) \
+    NESTED_FUNC (r, f, t, a)
+
+  #define INLINE_INTUSE_NESTED_FUNC(r, f, t, a) \
+    NESTED_FUNC (r, INTUSE(f), t, a)
+
+  /* Recrusive blocks need to be declared before used. */
+  #define RECURSIVE_NESTED_FUNC(return_type, function_name, \
+                      arg_types, arg_types_and_names) \
+    __BLOCK return_type (^function_name) arg_types; \
+    function_name = ^ return_type arg_types_and_names
+
+  #define INLINE_RECURSIVE_NESTED_FUNC(r, f, t, a) \
+    RECURSIVE_NESTED_FUNC (r, f, t, a)
+
+  #define INLINE_INTUSE_RECURSIVE_NESTED_FUNC(r, f, t, a) \
+    RECURSIVE_NESTED_FUNC (r, INTUSE(f), t, a)
+
+#else /* gcc nested function */
+
+  #define __BLOCK
+
+  #define NESTED_FUNC(return_type, function_name, \
+                      arg_types, arg_types_and_names) \
+    return_type function_name arg_types_and_names
+
+  #define INLINE_NESTED_FUNC(r, f, t, a) \
+    inline NESTED_FUNC (r, f, t, a)
+
+  #define INLINE_INTUSE_NESTED_FUNC(r, f, t, a) \
+    inline NESTED_FUNC (r, INTUSE(f), t, a)
+
+  #define RECURSIVE_NESTED_FUNC(r, f, t, a) \
+    NESTED_FUNC (r, f, t, a)
+
+  #define INLINE_RECURSIVE_NESTED_FUNC(r, f, t, a) \
+    inline RECURSIVE_NESTED_FUNC (r, f, t, a)
+
+  #define INLINE_INTUSE_RECURSIVE_NESTED_FUNC(r, f, t, a) \
+    INLINE_RECURSIVE_NESTED_FUNC (r, INTUSE(f), t, a)
+
+#endif
+
+#endif /* _NESTED_FUNC_H */
+
diff --git a/libebl/eblobjnote.c b/libebl/eblobjnote.c
index f7ac915c..360e28b8 100644
--- a/libebl/eblobjnote.c
+++ b/libebl/eblobjnote.c
@@ -581,7 +581,7 @@ ebl_object_note (Ebl *ebl, uint32_t namesz, const char *name, uint32_t type,
 		free (buf);
 	      break;
 	    }
-	  FALLTHROUGH;
+	  /* fall through */
 
 	default:
 	  /* Unknown type.  */
diff --git a/libelf/elf32_updatenull.c b/libelf/elf32_updatenull.c
index 5f3cdbf6..ee99eaa9 100644
--- a/libelf/elf32_updatenull.c
+++ b/libelf/elf32_updatenull.c
@@ -236,7 +236,7 @@ __elfw2(LIBELFBITS,updatenull_wrlock) (Elf *elf, int *change_bop, size_t shnum)
 		      __libelf_seterrno (ELF_E_GROUP_NOT_REL);
 		      return -1;
 		    }
-		  FALLTHROUGH;
+		  /* fall through */
 		case SHT_SYMTAB_SHNDX:
 		  sh_entsize = elf_typesize (32, ELF_T_WORD, 1);
 		  break;
diff --git a/libelf/elf_begin.c b/libelf/elf_begin.c
index 8107a103..c0584098 100644
--- a/libelf/elf_begin.c
+++ b/libelf/elf_begin.c
@@ -614,7 +614,7 @@ read_unmmaped_file (int fildes, int64_t offset, size_t maxsize, Elf_Cmd cmd,
 			     ? sizeof (Elf32_Ehdr) : sizeof (Elf64_Ehdr)))
 	return file_read_elf (fildes, NULL, mem.header, offset, maxsize, cmd,
 			      parent);
-      FALLTHROUGH;
+      /* fall through */
 
     default:
       break;
@@ -1143,7 +1143,7 @@ elf_begin (int fildes, Elf_Cmd cmd, Elf *ref)
 	  retval = NULL;
 	  break;
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case ELF_C_READ:
     case ELF_C_READ_MMAP:
diff --git a/libelf/elf_cntl.c b/libelf/elf_cntl.c
index fd681789..94d82027 100644
--- a/libelf/elf_cntl.c
+++ b/libelf/elf_cntl.c
@@ -62,7 +62,7 @@ elf_cntl (Elf *elf, Elf_Cmd cmd)
 	  result = -1;
 	  break;
 	}
-      FALLTHROUGH;
+      /* fall through */
 
     case ELF_C_FDDONE:
       /* Mark the file descriptor as not usable.  */
diff --git a/libelf/elf_update.c b/libelf/elf_update.c
index 9b8867ce..afb3aa82 100644
--- a/libelf/elf_update.c
+++ b/libelf/elf_update.c
@@ -91,6 +91,7 @@ write_file (Elf *elf, int64_t size, int change_bo, size_t shnum)
 	 fallback case might fail (with unexpected errnos) in some cases.
 	 So we only report an error when the call fails and errno is
 	 ENOSPC. Otherwise we ignore the error and treat it as just hint.  */
+#if 0
       if (elf->parent == NULL
 	  && (elf->maximum_size == ~((size_t) 0)
 	      || (size_t) size > elf->maximum_size))
@@ -116,6 +117,7 @@ write_file (Elf *elf, int64_t size, int change_bo, size_t shnum)
 	    }
 
 	}
+#endif
 
       /* The file is mmaped.  */
       if ((class == ELFCLASS32
diff --git a/libelf/libelfP.h b/libelf/libelfP.h
index b55d5c48..5f13d947 100644
--- a/libelf/libelfP.h
+++ b/libelf/libelfP.h
@@ -40,7 +40,7 @@
 #include <string.h>
 
 /* gettext helper macros.  */
-#define _(Str) dgettext ("elfutils", Str)
+#define _(Str) Str
 
 
 /* Helper Macros to write 32 bit and 64 bit functions.  */
diff --git a/libelf/libintl.h b/libelf/libintl.h
index e69de29b..b73e1995 100644
--- a/libelf/libintl.h
+++ b/libelf/libintl.h
@@ -0,0 +1 @@
+/* Empty stub for Android. */  
diff --git a/src/addr2line.c b/src/addr2line.c
index 69d8d995..ce5290aa 100644
--- a/src/addr2line.c
+++ b/src/addr2line.c
@@ -618,7 +618,7 @@ handle_address (const char *string, Dwfl *dwfl)
 	case 1:
 	  addr = 0;
 	  j = i;
-	  FALLTHROUGH;
+	  /* fall through */
 	case 2:
 	  if (string[j] != '\0')
 	    break;
@@ -692,19 +692,22 @@ handle_address (const char *string, Dwfl *dwfl)
 	  Dwarf_Line *info = dwfl_dwarf_line (line, &bias);
 	  assert (info != NULL);
 
-	  inline void show (int (*get) (Dwarf_Line *, bool *),
-			    const char *note)
-	  {
-	    bool flag;
-	    if ((*get) (info, &flag) == 0 && flag)
-	      fputs (note, stdout);
+		#define show(get_arg, note_arg) \
+	  { \
+	    int (*get) (Dwarf_Line *, bool *) = get_arg; \
+	    const char *note = note_arg; \
+	    bool flag; \
+	    if ((*get) (info, &flag) == 0 && flag) \
+	      fputs (note, stdout); \
 	  }
-	  inline void show_int (int (*get) (Dwarf_Line *, unsigned int *),
-				const char *name)
-	  {
-	    unsigned int val;
-	    if ((*get) (info, &val) == 0 && val != 0)
-	      printf (" (%s %u)", name, val);
+
+	  #define show_int(get_arg, name_arg) \
+	  { \
+	    int (*get) (Dwarf_Line *, unsigned int *) = get_arg; \
+	    const char *name = name_arg; \
+	    unsigned int val; \
+	    if ((*get) (info, &val) == 0 && val != 0) \
+	      printf (" (%s %u)", name, val); \
 	  }
 
 	  show (&dwarf_linebeginstatement, " (is_stmt)");
diff --git a/src/ar.c b/src/ar.c
index d70f1f46..410cea93 100644
--- a/src/ar.c
+++ b/src/ar.c
@@ -445,20 +445,21 @@ do_oper_extract (int oper, const char *arfname, char **argv, int argc,
   memset (found, '\0', sizeof (found));
 
   size_t name_max = 0;
-  inline bool should_truncate_fname (void)
-  {
-    if (errno == ENAMETOOLONG && allow_truncate_fname)
-      {
-	if (name_max == 0)
-	  {
-	    long int len = pathconf (".", _PC_NAME_MAX);
-	    if (len > 0)
-	      name_max = len;
-	  }
-	return name_max != 0;
-      }
-    return false;
-  }
+  #define should_truncate_fname() \
+  ( { \
+    bool result = false; \
+    if (errno == ENAMETOOLONG && allow_truncate_fname) \
+      { \
+	if (name_max == 0) \
+	  { \
+	    long int len = pathconf (".", _PC_NAME_MAX); \
+	    if (len > 0) \
+	      name_max = len; \
+	  } \
+	result = (name_max != 0); \
+      } \
+    result; \
+  } )
 
   off_t index_off = -1;
   size_t index_size = 0;
diff --git a/src/arlib-argp.c b/src/arlib-argp.c
index 1bdd8d0b..3b524799 100644
--- a/src/arlib-argp.c
+++ b/src/arlib-argp.c
@@ -59,13 +59,13 @@ parse_opt (int key, char *arg __attribute__ ((unused)),
 static char *
 help_filter (int key, const char *text, void *input __attribute__ ((unused)))
 {
-  inline char *text_for_default (void)
-  {
-    char *new_text;
-    if (unlikely (asprintf (&new_text, gettext ("%s (default)"), text) < 0))
-      return (char *) text;
-    return new_text;
-  }
+  #define text_for_default() \
+  ( { \
+    char *new_text; \
+    if (unlikely (asprintf (&new_text, gettext ("%s (default)"), text) < 0)) \
+      new_text = (char *) text; \
+    new_text; \
+  } )
 
   switch (key)
     {
diff --git a/src/elfcompress.c b/src/elfcompress.c
index 6ba6af41..60d9b406 100644
--- a/src/elfcompress.c
+++ b/src/elfcompress.c
@@ -149,7 +149,7 @@ parse_opt (int key, char *arg __attribute__ ((unused)),
 		    N_("Only one input file allowed together with '-o'"));
       /* We only use this for checking the number of arguments, we don't
 	 actually want to consume them.  */
-      FALLTHROUGH;
+      /* fall through */
     default:
       return ARGP_ERR_UNKNOWN;
     }
@@ -276,59 +276,51 @@ process_file (const char *fname)
   size_t shnum = 0;
 
 #define WORD_BITS (8U * sizeof (unsigned int))
-  void set_section (size_t ndx)
-  {
-    sections[ndx / WORD_BITS] |= (1U << (ndx % WORD_BITS));
-  }
+	#define set_section(ndx) \
+	  sections[ndx / WORD_BITS] |= (1U << (ndx % WORD_BITS))
 
-  bool get_section (size_t ndx)
-  {
-    return (sections[ndx / WORD_BITS] & (1U << (ndx % WORD_BITS))) != 0;
-  }
+	#define get_section(ndx) \
+	  ((sections[ndx / WORD_BITS] & (1U << (ndx % WORD_BITS))) != 0)
 
   /* How many sections are we going to change?  */
-  size_t get_sections (void)
-  {
-    size_t s = 0;
-    for (size_t i = 0; i < shnum / WORD_BITS + 1; i++)
-      s += __builtin_popcount (sections[i]);
-    return s;
-  }
-
-  int cleanup (int res)
-  {
-    elf_end (elf);
-    close (fd);
-
-    elf_end (elfnew);
-    close (fdnew);
-
-    if (fnew != NULL)
-      {
-	unlink (fnew);
-	free (fnew);
-	fnew = NULL;
-      }
-
-    free (snamebuf);
-    if (names != NULL)
-      {
-	dwelf_strtab_free (names);
-	free (scnstrents);
-	free (symstrents);
-	free (namesbuf);
-	if (scnnames != NULL)
-	  {
-	    for (size_t n = 0; n < shnum; n++)
-	      free (scnnames[n]);
-	    free (scnnames);
-	  }
-      }
-
-    free (sections);
-
-    return res;
-  }
+  #define get_sections() \
+  ( { \
+    size_t s = 0; \
+    for (size_t i = 0; i < shnum / WORD_BITS + 1; i++) \
+      s += __builtin_popcount (sections[i]); \
+    s; \
+  } )
+
+  #define cleanup(res) \
+	( { \
+			int result = res; \
+			elf_end (elf); \
+			close (fd); \
+			elf_end (elfnew); \
+			close (fdnew); \
+			if (fnew != NULL) \
+				{ \
+		unlink (fnew); \
+		free (fnew); \
+		fnew = NULL; \
+				} \
+			free (snamebuf); \
+			if (names != NULL) \
+				{ \
+		dwelf_strtab_free (names); \
+		free (scnstrents); \
+		free (symstrents); \
+		free (namesbuf); \
+		if (scnnames != NULL) \
+			{ \
+				for (size_t n = 0; n < shnum; n++) \
+					free (scnnames[n]); \
+				free (scnnames); \
+			} \
+				} \
+			free (sections); \
+		result; \
+	} )
 
   fd = open (fname, O_RDONLY);
   if (fd < 0)
diff --git a/src/elflint.c b/src/elflint.c
index edb466dd..24f6de9e 100644
--- a/src/elflint.c
+++ b/src/elflint.c
@@ -1763,7 +1763,7 @@ section [%2d] '%s': entry %zu: pointer does not match address of section [%2d] '
 	  if (dyn->d_tag < DT_ADDRRNGLO || dyn->d_tag > DT_ADDRRNGHI)
 	    /* Value is no pointer.  */
 	    break;
-	  FALLTHROUGH;
+	  /* fall through */
 
 	case DT_AUXILIARY:
 	case DT_FILTER:
@@ -3435,10 +3435,8 @@ check_attributes (Ebl *ebl, GElf_Ehdr *ehdr, GElf_Shdr *shdr, int idx)
       return;
     }
 
-  inline size_t pos (const unsigned char *p)
-  {
-    return p - (const unsigned char *) data->d_buf;
-  }
+  #define pos(p) \
+    ((const unsigned char *) (p) - (const unsigned char *) data->d_buf)
 
   const unsigned char *p = data->d_buf;
   if (*p++ != 'A')
@@ -3448,10 +3446,7 @@ check_attributes (Ebl *ebl, GElf_Ehdr *ehdr, GElf_Shdr *shdr, int idx)
       return;
     }
 
-  inline size_t left (void)
-  {
-    return (const unsigned char *) data->d_buf + data->d_size - p;
-  }
+  #define left() ((const unsigned char *) data->d_buf + data->d_size - p)
 
   while (left () >= 4)
     {
@@ -3995,7 +3990,7 @@ section [%2zu] '%s': merge flag set but entry size is zero\n"),
 	    case SHT_NOBITS:
 	      if (is_debuginfo)
 		break;
-	      FALLTHROUGH;
+	      /* fall through */
 	    default:
 	      ERROR (gettext ("\
 section [%2zu] '%s' has unexpected type %d for an executable section\n"),
@@ -4139,7 +4134,7 @@ section [%2zu] '%s': ELF header says this is the section header string table but
 	    ERROR (gettext ("\
 section [%2zu] '%s': relocatable files cannot have dynamic symbol tables\n"),
 		   cnt, section_name (ebl, cnt));
-	  FALLTHROUGH;
+	  /* fall through */
 	case SHT_SYMTAB:
 	  check_symtab (ebl, ehdr, shdr, cnt);
 	  break;
@@ -4362,7 +4357,7 @@ section [%2d] '%s': unknown core file note type %" PRIu32
 	    if (nhdr.n_namesz == sizeof "Linux"
 		&& !memcmp (data->d_buf + name_offset, "Linux", sizeof "Linux"))
 	      break;
-	    FALLTHROUGH;
+	    /* fall through */
 	  default:
 	    {
 	    unknown_note:
diff --git a/src/objdump.c b/src/objdump.c
index 6b365d5c..075c5f52 100644
--- a/src/objdump.c
+++ b/src/objdump.c
@@ -222,7 +222,7 @@ parse_opt (int key, char *arg,
 	}
       /* We only use this for checking the number of arguments, we don't
 	 actually want to consume them.  */
-      FALLTHROUGH;
+      /* fall through */
     default:
       return ARGP_ERR_UNKNOWN;
     }
diff --git a/src/readelf.c b/src/readelf.c
index 2084fb1f..9b0af70c 100644
--- a/src/readelf.c
+++ b/src/readelf.c
@@ -376,17 +376,19 @@ static error_t
 parse_opt (int key, char *arg,
 	   struct argp_state *state __attribute__ ((unused)))
 {
-  void add_dump_section (const char *name, bool implicit)
-  {
-    struct section_argument *a = xmalloc (sizeof *a);
-    a->arg = name;
-    a->next = NULL;
-    a->implicit = implicit;
-    struct section_argument ***tailp
-      = key == 'x' ? &dump_data_sections_tail : &string_sections_tail;
-    **tailp = a;
-    *tailp = &a->next;
-  }
+#define add_dump_section(_name, _implicit) \
+  ( { \
+		const char *name = _name; \
+		bool implicit = _implicit; \
+    struct section_argument *a = xmalloc (sizeof *a); \
+    a->arg = name; \
+    a->next = NULL; \
+    a->implicit = implicit; \
+    struct section_argument ***tailp \
+      = key == 'x' ? &dump_data_sections_tail : &string_sections_tail; \
+    **tailp = a; \
+    *tailp = &a->next; \
+  } )
 
   switch (key)
     {
@@ -544,7 +546,7 @@ parse_opt (int key, char *arg,
 	  print_string_sections = true;
 	  break;
 	}
-      FALLTHROUGH;
+      /* fall through */
     case 'x':
       add_dump_section (arg, false);
       any_control_option = true;
@@ -3595,10 +3597,7 @@ print_attributes (Ebl *ebl, const GElf_Ehdr *ehdr)
 
       fputs_unlocked (gettext ("  Owner          Size\n"), stdout);
 
-      inline size_t left (void)
-      {
-	return (const unsigned char *) data->d_buf + data->d_size - p;
-      }
+      #define left() ((const unsigned char *) data->d_buf + data->d_size - p)
 
       /* Loop over the sections.  */
       while (left () >= 4)
@@ -6163,11 +6162,12 @@ print_cfa_program (const unsigned char *readp, const unsigned char *const endp,
 		   Dwfl_Module *dwflmod, Ebl *ebl, Dwarf *dbg)
 {
   char regnamebuf[REGNAMESZ];
-  const char *regname (unsigned int regno)
-  {
-    register_info (ebl, regno, NULL, regnamebuf, NULL, NULL);
-    return regnamebuf;
-  }
+  #define regname(regno_arg) \
+  ( { \
+    unsigned int regno = regno_arg; \
+    register_info (ebl, regno, NULL, regnamebuf, NULL, NULL); \
+    regnamebuf; \
+  } )
 
   puts ("\n   Program:");
   Dwarf_Word pc = vma_base;
@@ -7118,7 +7118,7 @@ attr_callback (Dwarf_Attribute *attrp, void *arg)
 			dwarf_form_name (form), (uintmax_t) num);
 	      return DWARF_CB_OK;
 	    }
-	  FALLTHROUGH;
+	  /* fall through */
 
 	/* These cases always take a loclist[ptr] and no constant. */
 	case DW_AT_location:
@@ -7506,7 +7506,7 @@ attr_callback (Dwarf_Attribute *attrp, void *arg)
 	      print_block (block.length, block.data);
 	      break;
 	    }
-	  FALLTHROUGH;
+	  /* fall through */
 
 	case DW_AT_location:
 	case DW_AT_data_location:
@@ -8679,15 +8679,16 @@ print_debug_line_section (Dwfl_Module *dwflmod, Ebl *ebl, GElf_Ehdr *ehdr,
 	 or DW_LNS_advance_pc (as per DWARF4 6.2.5.1).  */
       unsigned int op_addr_advance;
       bool show_op_index;
-      inline void advance_pc (unsigned int op_advance)
-      {
-	op_addr_advance = minimum_instr_len * ((op_index + op_advance)
-					       / max_ops_per_instr);
-	address += op_addr_advance;
-	show_op_index = (op_index > 0 ||
-			 (op_index + op_advance) % max_ops_per_instr > 0);
-	op_index = (op_index + op_advance) % max_ops_per_instr;
-      }
+      #define advance_pc(op_advance_arg) \
+      ( { \
+        unsigned int op_advance = op_advance_arg; \
+				op_addr_advance = minimum_instr_len * ((op_index + (op_advance)) \
+											/ max_ops_per_instr); \
+				address += (op_advance); \
+				show_op_index = (op_index > 0 || \
+						(op_index + (op_advance)) % max_ops_per_instr > 0); \
+				op_index = (op_index + (op_advance)) % max_ops_per_instr; \
+      } )
 
       if (max_ops_per_instr == 0)
 	{
@@ -12002,14 +12003,16 @@ handle_core_registers (Ebl *ebl, Elf *core, const void *desc,
   qsort (regs, maxreg + 1, sizeof regs[0], &compare_registers);
 
   /* Collect the unique sets and sort them.  */
-  inline bool same_set (const struct register_info *a,
-			const struct register_info *b)
-  {
-    return (a < &regs[maxnreg] && a->regloc != NULL
-	    && b < &regs[maxnreg] && b->regloc != NULL
-	    && a->bits == b->bits
-	    && (a->set == b->set || !strcmp (a->set, b->set)));
-  }
+  #define same_set(a_arg, b_arg) \
+  ( { \
+    const struct register_info *a = a_arg; \
+    const struct register_info *b = b_arg; \
+    (a < &regs[maxnreg] && a->regloc != NULL \
+	    && b < &regs[maxnreg] && b->regloc != NULL \
+	    && a->bits == b->bits \
+	    && (a->set == b->set || !strcmp (a->set, b->set))); \
+  } )
+
   struct register_info *sets[maxreg + 1];
   sets[0] = &regs[0];
   size_t nsets = 1;
@@ -12082,7 +12085,7 @@ handle_auxv_note (Ebl *ebl, Elf *core, GElf_Word descsz, GElf_Off desc_pos)
 		printf ("    %s\n", name);
 		break;
 	      }
-	    FALLTHROUGH;
+	    /* fall through */
 	  case 'x':		/* hex */
 	  case 'p':		/* address */
 	  case 's':		/* address of string */
diff --git a/src/strings.c b/src/strings.c
index ef40d5ec..123425f7 100644
--- a/src/strings.c
+++ b/src/strings.c
@@ -245,7 +245,7 @@ parse_opt (int key, char *arg,
 	case 'b':
 	case 'B':
 	  big_endian = true;
-	  FALLTHROUGH;
+	  /* fall through */
 
 	case 'l':
 	case 'L':
diff --git a/src/strip.c b/src/strip.c
index 48792a70..2a882eab 100644
--- a/src/strip.c
+++ b/src/strip.c
@@ -442,84 +442,40 @@ update_shdrstrndx (Elf *elf, size_t shdrstrndx)
   return 0;
 }
 
-/* Remove any relocations between debug sections in ET_REL
-   for the debug file when requested.  These relocations are always
-   zero based between the unallocated sections.  */
-static void
-remove_debug_relocations (Ebl *ebl, Elf *elf, GElf_Ehdr *ehdr,
-			  const char *fname, size_t shstrndx)
+struct shdr_info
 {
-  Elf_Scn *scn = NULL;
-  while ((scn = elf_nextscn (elf, scn)) != NULL)
-    {
-      /* We need the actual section and header from the elf
-	 not just the cached original in shdr_info because we
-	 might want to change the size.  */
-      GElf_Shdr shdr_mem;
-      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-      if (shdr->sh_type == SHT_REL || shdr->sh_type == SHT_RELA)
-	{
-	  /* Make sure that this relocation section points to a
-	     section to relocate with contents, that isn't
-	     allocated and that is a debug section.  */
-	  Elf_Scn *tscn = elf_getscn (elf, shdr->sh_info);
-	  GElf_Shdr tshdr_mem;
-	  GElf_Shdr *tshdr = gelf_getshdr (tscn, &tshdr_mem);
-	  if (tshdr->sh_type == SHT_NOBITS
-	      || tshdr->sh_size == 0
-	      || (tshdr->sh_flags & SHF_ALLOC) != 0)
-	    continue;
-
-	  const char *tname =  elf_strptr (elf, shstrndx,
-					   tshdr->sh_name);
-	  if (! tname || ! ebl_debugscn_p (ebl, tname))
-	    continue;
-
-	  /* OK, lets relocate all trivial cross debug section
-	     relocations. */
-	  Elf_Data *reldata = elf_getdata (scn, NULL);
-	  if (reldata == NULL || reldata->d_buf == NULL)
-	    INTERNAL_ERROR (fname);
-
-	  /* Make sure we adjust the uncompressed debug data
-	     (and recompress if necessary at the end).  */
-	  GElf_Chdr tchdr;
-	  int tcompress_type = 0;
-	  bool is_gnu_compressed = false;
-	  if (strncmp (tname, ".zdebug", strlen ("zdebug")) == 0)
-	    {
-	      is_gnu_compressed = true;
-	      if (elf_compress_gnu (tscn, 0, 0) != 1)
-		INTERNAL_ERROR (fname);
-	    }
-	  else
-	    {
-	      if (gelf_getchdr (tscn, &tchdr) != NULL)
-		{
-		  tcompress_type = tchdr.ch_type;
-		  if (elf_compress (tscn, 0, 0) != 1)
-		    INTERNAL_ERROR (fname);
-		}
-	    }
+  Elf_Scn *scn;
+  GElf_Shdr shdr;
+  Elf_Data *data;
+  Elf_Data *debug_data;
+  const char *name;
+  Elf32_Word idx;		/* Index in new file.  */
+  Elf32_Word old_sh_link;	/* Original value of shdr.sh_link.  */
+  Elf32_Word symtab_idx;
+  Elf32_Word version_idx;
+  Elf32_Word group_idx;
+  Elf32_Word group_cnt;
+  Elf_Scn *newscn;
+  Dwelf_Strent *se;
+  Elf32_Word *newsymidx;
+};
 
-	  Elf_Data *tdata = elf_getdata (tscn, NULL);
-	  if (tdata == NULL || tdata->d_buf == NULL
-	      || tdata->d_type != ELF_T_BYTE)
-	    INTERNAL_ERROR (fname);
+#define declare_relocate_closure \
+  Ebl * const ebl, \
+	Elf * const elf, \
+  Elf_Data * const symdata, \
+  Elf_Data * const xndxdata, \
+  const char * const fname, \
+  Elf_Data * const tdata, \
+  GElf_Ehdr * const ehdr
 
-	  /* Pick up the symbol table and shndx table to
-	     resolve relocation symbol indexes.  */
-	  Elf64_Word symt = shdr->sh_link;
-	  Elf_Data *symdata, *xndxdata;
-	  Elf_Scn * symscn = elf_getscn (elf, symt);
-	  symdata = elf_getdata (symscn, NULL);
-	  xndxdata = get_xndxdata (elf, symscn);
-	  if (symdata == NULL)
-	    INTERNAL_ERROR (fname);
+#define pass_relocate_closure \
+  ebl, elf, symdata, xndxdata, fname, tdata, ehdr
 
-	  /* Apply one relocation.  Returns true when trivial
-	     relocation actually done.  */
-	  bool relocate (GElf_Addr offset, const GElf_Sxword addend,
+/* Apply one relocation.  Returns true when trivial
+  relocation actually done.  */
+static bool
+relocate (declare_relocate_closure, GElf_Addr offset, const GElf_Sxword addend,
 			 bool is_rela, int rtype, int symndx)
 	  {
 	    /* R_*_NONE relocs can always just be removed.  */
@@ -656,7 +612,82 @@ remove_debug_relocations (Ebl *ebl, Elf *elf, GElf_Ehdr *ehdr,
 		return true;
 	      }
 	    return false;
-	  }
+}
+
+/* Remove any relocations between debug sections in ET_REL
+   for the debug file when requested.  These relocations are always
+   zero based between the unallocated sections.  */
+static void
+remove_debug_relocations (Ebl *ebl, Elf *elf, GElf_Ehdr *ehdr,
+			  const char *fname, size_t shstrndx)
+{
+  Elf_Scn *scn = NULL;
+  while ((scn = elf_nextscn (elf, scn)) != NULL)
+    {
+      /* We need the actual section and header from the elf
+	 not just the cached original in shdr_info because we
+	 might want to change the size.  */
+      GElf_Shdr shdr_mem;
+      GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
+      if (shdr->sh_type == SHT_REL || shdr->sh_type == SHT_RELA)
+	{
+	  /* Make sure that this relocation section points to a
+	     section to relocate with contents, that isn't
+	     allocated and that is a debug section.  */
+	  Elf_Scn *tscn = elf_getscn (elf, shdr->sh_info);
+	  GElf_Shdr tshdr_mem;
+	  GElf_Shdr *tshdr = gelf_getshdr (tscn, &tshdr_mem);
+	  if (tshdr->sh_type == SHT_NOBITS
+	      || tshdr->sh_size == 0
+	      || (tshdr->sh_flags & SHF_ALLOC) != 0)
+	    continue;
+
+	  const char *tname =  elf_strptr (elf, shstrndx,
+					   tshdr->sh_name);
+	  if (! tname || ! ebl_debugscn_p (ebl, tname))
+	    continue;
+
+	  /* OK, lets relocate all trivial cross debug section
+	     relocations. */
+	  Elf_Data *reldata = elf_getdata (scn, NULL);
+	  if (reldata == NULL || reldata->d_buf == NULL)
+	    INTERNAL_ERROR (fname);
+
+	  /* Make sure we adjust the uncompressed debug data
+	     (and recompress if necessary at the end).  */
+	  GElf_Chdr tchdr;
+	  int tcompress_type = 0;
+	  bool is_gnu_compressed = false;
+	  if (strncmp (tname, ".zdebug", strlen ("zdebug")) == 0)
+	    {
+	      is_gnu_compressed = true;
+	      if (elf_compress_gnu (tscn, 0, 0) != 1)
+		INTERNAL_ERROR (fname);
+	    }
+	  else
+	    {
+	      if (gelf_getchdr (tscn, &tchdr) != NULL)
+		{
+		  tcompress_type = tchdr.ch_type;
+		  if (elf_compress (tscn, 0, 0) != 1)
+		    INTERNAL_ERROR (fname);
+		}
+	    }
+
+	  Elf_Data *tdata = elf_getdata (tscn, NULL);
+	  if (tdata == NULL || tdata->d_buf == NULL
+	      || tdata->d_type != ELF_T_BYTE)
+	    INTERNAL_ERROR (fname);
+
+	  /* Pick up the symbol table and shndx table to
+	     resolve relocation symbol indexes.  */
+	  Elf64_Word symt = shdr->sh_link;
+	  Elf_Data *symdata, *xndxdata;
+	  Elf_Scn * symscn = elf_getscn (elf, symt);
+	  symdata = elf_getdata (symscn, NULL);
+	  xndxdata = get_xndxdata (elf, symscn);
+	  if (symdata == NULL)
+	    INTERNAL_ERROR (fname);
 
 	  if (shdr->sh_entsize == 0)
 	    INTERNAL_ERROR (fname);
@@ -668,7 +699,8 @@ remove_debug_relocations (Ebl *ebl, Elf *elf, GElf_Ehdr *ehdr,
 	      {
 		GElf_Rel rel_mem;
 		GElf_Rel *r = gelf_getrel (reldata, relidx, &rel_mem);
-		if (! relocate (r->r_offset, 0, false,
+		if (! relocate (pass_relocate_closure,
+				r->r_offset, 0, false,
 				GELF_R_TYPE (r->r_info),
 				GELF_R_SYM (r->r_info)))
 		  {
@@ -682,7 +714,8 @@ remove_debug_relocations (Ebl *ebl, Elf *elf, GElf_Ehdr *ehdr,
 	      {
 		GElf_Rela rela_mem;
 		GElf_Rela *r = gelf_getrela (reldata, relidx, &rela_mem);
-		if (! relocate (r->r_offset, r->r_addend, true,
+		if (! relocate (pass_relocate_closure,
+				r->r_offset, r->r_addend, true,
 				GELF_R_TYPE (r->r_info),
 				GELF_R_SYM (r->r_info)))
 		  {
@@ -936,23 +969,7 @@ handle_elf (int fd, Elf *elf, const char *prefix, const char *fname,
   GElf_Off lastsec_offset = 0;
   Elf64_Xword lastsec_size = 0;
   size_t shstrndx;
-  struct shdr_info
-  {
-    Elf_Scn *scn;
-    GElf_Shdr shdr;
-    Elf_Data *data;
-    Elf_Data *debug_data;
-    const char *name;
-    Elf32_Word idx;		/* Index in new file.  */
-    Elf32_Word old_sh_link;	/* Original value of shdr.sh_link.  */
-    Elf32_Word symtab_idx;
-    Elf32_Word version_idx;
-    Elf32_Word group_idx;
-    Elf32_Word group_cnt;
-    Elf_Scn *newscn;
-    Dwelf_Strent *se;
-    Elf32_Word *newsymidx;
-  } *shdr_info = NULL;
+  struct shdr_info *shdr_info = NULL;
   Elf_Scn *scn;
   size_t cnt;
   size_t idx;
@@ -1536,20 +1553,20 @@ handle_elf (int fd, Elf *elf, const char *prefix, const char *fname,
 		 file's .data pointer.  Below, we'll copy the section
 		 contents.  */
 
-	      inline void check_preserved (size_t i)
-	      {
-		if (i != 0 && i < shnum + 2 && shdr_info[i].idx != 0
-		    && shdr_info[i].debug_data == NULL)
-		  {
-		    if (shdr_info[i].data == NULL)
-		      shdr_info[i].data = elf_getdata (shdr_info[i].scn, NULL);
-		    if (shdr_info[i].data == NULL)
-		      INTERNAL_ERROR (fname);
-
-		    shdr_info[i].debug_data = shdr_info[i].data;
-		    changes |= i < cnt;
-		  }
-	      }
+	    #define check_preserved(i_arg) \
+	    { \
+				size_t i = i_arg; \
+				if (i != 0 && i < shnum + 2 && shdr_info[i].idx != 0 \
+						&& shdr_info[i].debug_data == NULL) \
+					{ \
+						if (shdr_info[i].data == NULL) \
+							shdr_info[i].data = elf_getdata (shdr_info[i].scn, NULL); \
+						if (shdr_info[i].data == NULL) \
+							INTERNAL_ERROR (fname); \
+						shdr_info[i].debug_data = shdr_info[i].data; \
+						changes |= i < cnt; \
+					} \
+ 	    }
 
 	      check_preserved (shdr_info[cnt].shdr.sh_link);
 	      if (SH_INFO_LINK_P (&shdr_info[cnt].shdr))
@@ -2127,22 +2144,23 @@ handle_elf (int fd, Elf *elf, const char *prefix, const char *fname,
 	/* Update section headers when the data size has changed.
 	   We also update the SHT_NOBITS section in the debug
 	   file so that the section headers match in sh_size.  */
-	inline void update_section_size (const Elf_Data *newdata)
-	{
-	  GElf_Shdr shdr_mem;
-	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem);
-	  shdr->sh_size = newdata->d_size;
-	  (void) gelf_update_shdr (scn, shdr);
-	  if (debugelf != NULL)
-	    {
-	      /* libelf will use d_size to set sh_size.  */
-	      Elf_Data *debugdata = elf_getdata (elf_getscn (debugelf,
-							     cnt), NULL);
-	      if (debugdata == NULL)
-		INTERNAL_ERROR (fname);
-	      debugdata->d_size = newdata->d_size;
-	    }
-	}
+	#define update_section_size(newdata_arg) \
+	( { \
+	  const Elf_Data *newdata = newdata_arg; \
+	  GElf_Shdr shdr_mem; \
+	  GElf_Shdr *shdr = gelf_getshdr (scn, &shdr_mem); \
+	  shdr->sh_size = newdata->d_size; \
+	  (void) gelf_update_shdr (scn, shdr); \
+	  if (debugelf != NULL) \
+	    { \
+	      /* libelf will use d_size to set sh_size.  */ \
+	      Elf_Data *debugdata = elf_getdata (elf_getscn (debugelf, \
+							     cnt), NULL); \
+	      if (debugdata == NULL) \
+		INTERNAL_ERROR (fname); \
+	      debugdata->d_size = newdata->d_size; \
+	    } \
+ 	} )
 
 	if (shdr_info[cnt].idx == 0 && debug_fname == NULL)
 	  /* Ignore sections which are discarded.  When we are saving a
@@ -2155,18 +2173,21 @@ handle_elf (int fd, Elf *elf, const char *prefix, const char *fname,
 	const Elf32_Word *const newsymidx = shdr_info[symtabidx].newsymidx;
 	switch (shdr_info[cnt].shdr.sh_type)
 	  {
-	    inline bool no_symtab_updates (void)
-	    {
-	      /* If the symbol table hasn't changed, do not do anything.  */
-	      if (shdr_info[symtabidx].newsymidx == NULL)
-		return true;
-
-	      /* If the symbol table is not discarded, but additionally
-		 duplicated in the separate debug file and this section
-		 is discarded, don't adjust anything.  */
-	      return (shdr_info[cnt].idx == 0
-		      && shdr_info[symtabidx].debug_data != NULL);
-	    }
+	    #define no_symtab_updates() \
+	    ( { \
+	        bool no_updates; \
+	        /* If the symbol table hasn't changed, do not do anything.  */ \
+	        if (shdr_info[symtabidx].newsymidx == NULL) { \
+	          no_updates = true; \
+	        } else { \
+	          /* If the symbol table is not discarded, but additionally */ \
+	          /* duplicated in the separate debug file and this section */ \
+	          /* is discarded, don't adjust anything. */ \
+	          no_updates = (shdr_info[cnt].idx == 0 \
+	                        && shdr_info[symtabidx].debug_data != NULL); \
+	        } \
+	        no_updates; \
+	    } )
 
 	  case SHT_REL:
 	  case SHT_RELA:
diff --git a/src/unstrip.c b/src/unstrip.c
index fc878325..797a7249 100644
--- a/src/unstrip.c
+++ b/src/unstrip.c
@@ -437,11 +437,12 @@ adjust_relocs (Elf_Scn *outscn, Elf_Scn *inscn, const GElf_Shdr *shdr,
 {
   Elf_Data *data = elf_getdata (outscn, NULL);
 
-  inline void adjust_reloc (GElf_Xword *info)
-    {
-      size_t ndx = GELF_R_SYM (*info);
-      if (ndx != STN_UNDEF)
-	*info = GELF_R_INFO (map[ndx - 1], GELF_R_TYPE (*info));
+  #define adjust_reloc(info_arg) \
+    { \
+      GElf_Xword *info = info_arg; \
+      size_t ndx = GELF_R_SYM (*info); \
+      if (ndx != STN_UNDEF) \
+        *info = GELF_R_INFO (map[ndx - 1], GELF_R_TYPE (*info)); \
     }
 
   switch (shdr->sh_type)
@@ -1186,14 +1187,17 @@ find_alloc_sections_prelink (Elf *debug, Elf_Data *debug_shstrtab,
     }
 
   bool fail = false;
-  inline void check_match (bool match, Elf_Scn *scn, const char *name)
-    {
-      if (!match)
-	{
-	  fail = true;
-	  error (0, 0, _("cannot find matching section for [%zu] '%s'"),
-		 elf_ndxscn (scn), name);
-	}
+  #define check_match(match_arg, scn_arg, name_arg) \
+    { \
+      bool match = match_arg; \
+      Elf_Scn *scnp = scn_arg; \
+      const char *sect_name = name_arg; \
+      if (!match) \
+      { \
+        fail = true; \
+        error (0, 0, _("cannot find matching section for [%zu] '%s'"), \
+               elf_ndxscn (scnp), sect_name); \
+      } \
     }
 
   Elf_Scn *scn = NULL;
@@ -1422,27 +1426,31 @@ more sections in stripped file than debug file -- arguments reversed?"));
     }
 
   /* Locate a matching unallocated section in SECTIONS.  */
-  inline struct section *find_unalloc_section (const GElf_Shdr *shdr,
-					       const char *name,
-					       const char *sig)
-    {
-      size_t l = nalloc, u = stripped_shnum - 1;
-      while (l < u)
-	{
-	  size_t i = (l + u) / 2;
-	  struct section *sec = &sections[i];
-	  int cmp = compare_unalloc_sections (shdr, &sec->shdr,
-					      name, sec->name,
-					      sig, sec->sig);
-	  if (cmp < 0)
-	    u = i;
-	  else if (cmp > 0)
-	    l = i + 1;
-	  else
-	    return sec;
-	}
-      return NULL;
-    }
+  #define find_unalloc_section(shdr_arg, name_arg, sig_arg) \
+  ( { \
+      const GElf_Shdr *shdr_p = shdr_arg; \
+      const char *sect_name = name_arg; \
+      const char *sig = sig_arg; \
+      struct section * result = NULL; \
+      size_t l = nalloc, u = stripped_shnum - 1; \
+      while (l < u) \
+      { \
+        size_t i = (l + u) / 2; \
+        struct section *secp = &sections[i]; \
+        int cmp = compare_unalloc_sections (shdr_p, &secp->shdr, \
+                                            sect_name, secp->name, \
+                                            sig, sec->sig); \
+        if (cmp < 0) \
+          u = i; \
+        else if (cmp > 0) \
+          l = i + 1; \
+        else { \
+          result = secp; \
+          break; \
+        } \
+      } \
+    result; \
+  } )
 
   Elf_Data *shstrtab = elf_getdata (elf_getscn (unstripped,
 						unstripped_shstrndx), NULL);
@@ -2184,12 +2192,13 @@ handle_explicit_files (const char *output_file, bool create_dirs, bool force,
 
   /* Warn, and exit if not forced to continue, if some ELF header
      sanity check for the stripped and unstripped files failed.  */
-  void warn (const char *msg)
-  {
-    error (force ? 0 : EXIT_FAILURE, 0, "%s'%s' and '%s' %s%s.",
-	   force ? _("WARNING: ") : "",
-	   stripped_file, unstripped_file, msg,
-	   force ? "" : _(", use --force"));
+  #define warn(msg_arg) \
+  { \
+    const char *msg = msg_arg; \
+    error (force ? 0 : EXIT_FAILURE, 0, "%s'%s' and '%s' %s%s.", \
+	   force ? _("WARNING: ") : "", \
+	   stripped_file, unstripped_file, msg, \
+	   force ? "" : _(", use --force")); \
   }
 
   int stripped_fd = open_file (stripped_file, false);
@@ -2445,10 +2454,11 @@ static void
 handle_implicit_modules (const struct arg_info *info)
 {
   struct match_module_info mmi = { info->args, NULL, info->match_files };
-  inline ptrdiff_t next (ptrdiff_t offset)
-    {
-      return dwfl_getmodules (info->dwfl, &match_module, &mmi, offset);
-    }
+  #define next(offset_arg) \
+  ( { \
+    ptrdiff_t old_offset = offset_arg; \
+    dwfl_getmodules (info->dwfl, &match_module, &mmi, old_offset); \
+  } )
   ptrdiff_t offset = next (0);
   if (offset == 0)
     error (EXIT_FAILURE, 0, _("no matching modules found"));
